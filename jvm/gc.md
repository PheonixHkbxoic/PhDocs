垃圾回收：回收不再使用(存活)的对象并释放对应内存

怎么知道对象死没死？

**一、引用计数法**

它的做法是为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为0，则说明该对象已经死亡，便可以被回收了。

它的具体实现是这样子的：如果有一个引用，被赋值为某一对象，那么将该对象的引用计数器+1。如果一个指向某一对象的引用，被赋值为其他值，那么将该对象的引用计数器 -1。

除了需要额外的空间来存储计数器，以及繁琐的更新计数器以外；引用计数法还有一个重大的漏洞：无法处理循环引用。

**二、可达性分析**

这种算法的思路在于：将一系列被称为GC Roots的变量作为初始的存活对象合集，然后从该合集出发，所有能够被该集合引用到的对象，并将其加入到该集合中，而不能被该合集所引用到的对象，并可对其宣告死亡。

那么什么是 GC Roots 呢？

注意这句话：GC Roots是一些由堆外指向堆内的引用，

一般而言，GC Roots 包括（但不限于）如下几种：

*   虚拟机栈（栈帧中的本地变量表）中的引用的对象；
*   方法区中类静态属性引用的对象；
*   方法区中常量引用的对象；

*   本地方法栈中JNI（一般说的Native方法）的引用的对象。

*   已启动且未停止的 Java 线程。

可达性分析可以解决引用计数法所不能解决的循环引用问题。举例来说，即便对象 a 和 b 相互引用，只要从 GC Roots 出发无法到达 a 或者 b，那么a和b就是死亡的对象。



**快速找到GC ROOTS:OopMap**

当所有线程停下来的时候，并不需要一个不漏的检查完所有执行上下文和全局引用位置，虚拟机应该是有办法直接知道哪些地方存放着对象引用。在HotSpot的实现中，是使用一组称为OopMap的数据结构来达到目的的。

**OopMap存储两种对象引用：**

**1、对象内的引用**

在类加载完的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来。

**2、栈、寄存器中引用**

在JIT编辑过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC在扫描的时候就知道这些信息了。

通过OopMap垃圾收集器就可以更快的找到GC Roots，并且更快的完成GC Roots的枚举，大概展示如下图：

![img](https://gitee.com/HKbxOIC/imgs/raw/master/PhDocs/gc_oopmap.jpeg)



**Stop-the-world以及安全点**

在 Java 虚拟机里，传统的垃圾回收算法采用的是一种简单粗暴的方式，那便是 Stop-the-world，停止其他非垃圾回收线程的工作，直到完成垃圾回收。这也就造成了垃圾回收所谓的暂停时间（GC pause）。

Java 虚拟机中的 Stop-the-world 是通过安全点（safepoint）机制来实现的。当 Java 虚拟机收到 Stop-the-world 请求，它便会等待所有的线程都到达安全点，才会停止所有线程，并允许请求Stop-the-world的那个线程进行独占的工作。

当然也并非蛮横的强制停止，毕竟多线程情况下，啥事都可能发生。安全点的初始目的并不是让其他线程停下，而是找到一个稳定的执行状态。在这个执行状态下，Java 虚拟机的堆栈不会发生变化。

**安全点选择标准**

**是否就有让程序长时间执行的特征。**一条指令执行时间都很短，而一段程序一般不会说因为很长的指令流而造成长时间的运行，所以一般都是在指令复用的地方出现。比如：**方法调用、循环跳转、异常跳转**。



**三、垃圾回收的三种方式**

通过上文我们聊到的可达性分析，我们可以对死亡对象宣判死刑。那么接下来我们便可以对死亡对象进行回收工作了。主流的基础回收方式可分为三种。

**3.1、清除（sweep）**

常见的一种叫法：标记清除

思想：把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（free list）之中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。

清除这种回收方式的原理及其简单，但是有两个缺点：

1、造成内存碎片。由于 Java 虚拟机的堆中对象必须是连续分布的，因此可能出现总空闲内存足够，但是无法分配的极端情况。比如：总空间100M，此时我们需要申请100M的数组。但是由于内存不连续，因此我们就会申请失败。2、分配效率较低。如果是一块连续的内存空间，那么我们可以通过指针加法（pointer bumping）来做分配。而对于空闲列表，Java 虚拟机则需要逐个访问列表中的项，来查找能够放入新建对象的空闲内存。

**3.2、压缩（compact）**

常见的一种叫法：标记整理

思想：把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。

这种做法优缺点都比较的明显：

优点：能够解决内存碎片化的问题缺点：压缩算法的性能开销

**3.3、复制（copy）**

思想：把内存区域分为两等分，分别用两个指针 from 和 to 来维护，并且只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到 to 指针指向的内存区域中，并且交换 from 指针和 to 指针的内容。

这种做法的优缺点同样明显：

优点：能够解决内存碎片化的问题缺点：堆空间的使用效率极其低下（毕竟分成两半，一次只使用一半）

![](D:\typora\PhDocs\imgs\gc.png)
