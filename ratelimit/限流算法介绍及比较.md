

[toc]



>   保障服务稳定的三大利器：
>
>   熔断降级、服务限流和故障模拟。限流包括Nginx层面的限流以及业务代码逻辑上的限流。



## 一、为什么需要限流

以服务的调用方来看，可以分为两种类型服务

-   对外提供的服务（web服务）
     这类服务有以下几种可能导致机器被拖垮：
     1.用户增长过快
     2.热点事件
     3.爬虫
     4.刷单
-   对内提供的服务（微服务之间调用）
     一个服务A的接口假如被BCDE等多个服务进行调用，如果B服务发生突发流量，就会直接把A服务调用挂了，会导致CDE无法正常使用。
     解决方案：
     1.每个调用方采用线程池进行资源隔离（避免资源被耗尽无法分配资源）
     2.使用限流手段对每个调用方进行限流



## 二、限流算法

常见的限流算法有：计数器、令牌桶、漏桶。

归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



### 1、计数器（固定窗口）算法

计数器算法是使用计数器在周期内累加访问次数，当达到设定的限流值时，触发限流策略。下一个周期开始时，进行清零，重新计数。

此算法在单机还是分布式环境下实现都非常简单，使用redis的incr原子自增性和线程安全即可轻松实现。

 ![img](https://gitee.com/HKbxOIC/imgs/raw/master/PhDocs/ratelimit/fixed-window.png)

 


这个算法通常用于QPS限流和统计总访问量，对于秒级以上的时间周期来说，会存在一个非常严重的问题，那就是临界问题，如下图：

![img](https://gitee.com/HKbxOIC/imgs/raw/master/PhDocs/ratelimit/fixed-window-optimized.png)

假设1min内服务器的负载能力为100，因此一个周期的访问量限制在100，然而在第一个周期的最后5秒和下一个周期的开始5秒时间段内，分别涌入100的访问量，虽然没有超过每个周期的限制量，但是整体上10秒内已达到200的访问量，已远远超过服务器的负载能力，由此可见，计数器算法方式限流对于周期比较长的限流，存在很大的弊端。



### 2、滑动窗口算法

滑动窗口算法是将时间周期分为N个小周期，分别记录每个小周期内访问次数，并且根据时间滑动删除过期的小周期。

如下图，假设时间周期为1min，将1min再分为2个小周期，统计每个小周期的访问数量，则可以看到，第一个时间周期内，访问数量为75，第二个时间周期内，访问数量为100，超过100的访问则被限流掉了   

 ![img](https://gitee.com/HKbxOIC/imgs/raw/master/PhDocs/ratelimit/sliding-window.png)



由此可见，当滑动窗口的格子划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确。

此算法可以很好的解决固定窗口算法的临界问题。



### 3、漏桶算法

漏桶算法是访问请求到达时直接放入漏桶，如当前容量已达到上限（限流值），则进行丢弃（触发限流策略）。漏桶以固定的速率进行释放访问请求（即请求通过），直到漏桶为空。

<img src="https://gitee.com/HKbxOIC/imgs/raw/master/PhDocs/ratelimit/leakey-buket.png" alt="img"  />



### 4、令牌桶算法

令牌桶算法是程序以r（r=时间周期/限流值）的速度向令牌桶中增加令牌，直到令牌桶满，请求到达时向令牌桶请求令牌，如获取到令牌则通过请求，否则触发限流策略

![img](https://gitee.com/HKbxOIC/imgs/raw/master/PhDocs/ratelimit/token-buket.png)

 

各个算法比较

![image-20200423143355266](https://gitee.com/HKbxOIC/imgs/raw/master/PhDocs/ratelimit/ratelimit_algorithm_compare.png)



## 三、链接

https://blog.csdn.net/weixin_41846320/java/article/details/95941361